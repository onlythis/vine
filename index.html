<!DOCTYPE html>
<html lang="en">
<head>
	<title>Vine</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0,
	 maximum-scale=1.0">
	<style>
	body {
		color: #cccccc;
		font-family:Monospace;
		font-size:13px;
		text-align:center;
		background-color: #050505;
		margin: 0px;
		overflow: hidden;
	}
	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 5px;
	}
	</style>
</head>
<body>
	<div id="info">Left click: rotate. Right click: translate. Scroll: zoom.</div>
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
	<script>

	'use strict';

	var spin=0;
	var prev_root = [0,0,0];
	var prev_arm = [0,0,0];

	function render() {
		//red squares position
		root.position.x=Math.round(Math.sin(spin)*15)*4;
		root.position.z=Math.round(Math.cos(spin)*15)*4;
		root.position.y=Math.round(spin*15/Math.PI)*4;
		middle.position.y = spin*15/Math.PI*4-20;
		//follows red squares but doesn't round
		revolve.position.x=Math.sin(spin)*15*4;
		revolve.position.z=Math.cos(spin)*15*4;
		revolve.position.y=spin*15/Math.PI*4;
		revolve.rotateY(.005);

		//arm is child of revolve.
		arm.position.z = Math.sin(spin*8)*8;
		arm.position.y = Math.cos(spin*8)*8;

		worldpos.setFromMatrixPosition(root.matrixWorld);
		let root_pos = new Array(worldpos.x,worldpos.y,worldpos.z);
		let is_same_root = prev_root.every(function(element, index) {
			return element === root_pos[index];});

		if(!is_same_root) {
			drawroot(root_pos, spin);
			prev_root = new Array(root_pos[0],root_pos[1],root_pos[2]);
		}

		worldpos.setFromMatrixPosition(arm.matrixWorld);
		let arm_pos = new Array(Math.round(worldpos.x/2)*2,Math.round(worldpos.y/2)*2,
			Math.round(worldpos.z/2)*2);
		let is_same_arm = prev_arm.every(function(element, index) {
			return element === arm_pos[index];});

		if(!is_same_arm) {
			drawbranch(arm_pos, spin);
			prev_arm = new Array(arm_pos[0], arm_pos[1], arm_pos[2]);
		}



		if(spin<Math.PI*8){
			spin+=.005;
		} else {
			continueAnim=false;
		}
		renderer.render(scene, camera);
	}


	var pos = [];
	var root, revolve, center, arm, middle;
	var scene, camera, renderer, controls;
	var worldpos = new THREE.Vector3();
	var width = window.innerWidth, height = window.innerHeight;
	var animframe;
	var continueAnim = true;

	function init() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(35, width / height, 0.3, 1000);
		scene.position.y-=20;
		camera.position.z = 200;
		camera.position.y = 200;
		camera.position.x = 50;
		camera.lookAt(scene.position);

		root = new THREE.Mesh(boxGeoinvis, boxMatinvis);
		scene.add(root);

		revolve = new THREE.Mesh(boxGeoinvis, boxMatinvis);
		arm = new THREE.Mesh(boxGeo, boxMat2);
		middle = new THREE.Mesh(boxGeo, boxMat);

		scene.add(middle);
		scene.add(revolve);
		revolve.add(arm);


		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(width, height);
		renderer.setClearColor(0x0E2255);
		renderer.shadowMap.enabled = true;

		controls = new THREE.OrbitControls(camera, renderer.domElement);

		const ambientLight = new THREE.AmbientLight();
		scene.add(ambientLight);

		const light = new THREE.DirectionalLight();
		light.position.set(200, 100, 200);
		light.castShadow = true;
		light.shadow.camera.left = -100;
		light.shadow.camera.right = 100;
		light.shadow.camera.top = 100;
		light.shadow.camera.bottom = -100;
		scene.add(light);
		//drawroot([0,0,0]);
		drawcenter();
		document.body.appendChild(renderer.domElement);

		window.addEventListener('resize', onResize);
	}


		function drawroot(loc, spin) {
			let center = new THREE.Group();
			let set = new Array(loc[0],loc[1],loc[2]);
			scene.add(center);
			const obj = new THREE.Mesh(boxGeo, boxMat);
			obj.castShadow = true;
			obj.receiveShadow = true;
			obj.position.set(set[0],set[1],set[2]);
			pos.push(obj);
			center.add(obj);
		}

		function drawbranch(loc, rot) {
			let center = new THREE.Group();
			let set = new Array(loc[0],loc[1],loc[2]);
			scene.add(center);
			const boxGeo = new THREE.CubeGeometry(2,2,2);

			const obj = new THREE.Mesh(boxGeo, boxMat2);
			obj.castShadow = true;
			obj.receiveShadow = true;
			obj.position.set(set[0],set[1],set[2]);
			obj.rotateY(rot);
			center.add(obj);
			return obj;
		}

		function drawcenter() {
			let center = new THREE.Group();
			scene.add(center);
			const boxGeo = new THREE.CubeGeometry(120,4,120);
			const boxMat = new THREE.MeshPhongMaterial({
				color: new THREE.Color("rgb(0, 0, 128)"),
				shading: THREE.FlatShading,
				transparent: true,
				opacity: .5
			});
			const obj = new THREE.Mesh(boxGeo, boxMat);
			obj.castShadow = true;
			obj.receiveShadow = true;
			worldpos.setFromMatrixPosition(obj.matrixWorld);
			obj.position.set(worldpos.x,worldpos.y,worldpos.z);
			center.add(obj);
			return obj;
		}

	function onResize() {
		width = window.innerWidth;
		height = window.innerHeight;
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		renderer.setSize(width, height);
	}

	function animate() {
		animframe = requestAnimationFrame(animate);
		render();
		if(!continueAnim){
			cancelAnimationFrame(animframe);
		}
	}

	var boxGeo = new THREE.CubeGeometry(4,4,4);
	var boxMat = new THREE.MeshPhongMaterial({
		color: new THREE.Color("rgb(255, 0, 0)"),
		shading: THREE.FlatShading,
		transparent: true,
		opacity: .5
	});
	var boxGeo2 = new THREE.CubeGeometry(4,4,2);
	var boxMat2 = new THREE.MeshPhongMaterial({
		color: new THREE.Color("rgb(0, 255, 0)"),
		shading: THREE.FlatShading,
		transparent: true,
		opacity: .5
	});
	var boxGeoinvis = new THREE.CubeGeometry(0,0,0);
	var boxMatinvis = new THREE.MeshPhongMaterial({
		color: new THREE.Color("rgb(0, 0, 0)"),
		transparent: true,
		opacity: 1
	});

	init();
	animate();

	</script>
</body>
</html>
